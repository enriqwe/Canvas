<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagramador de Canvas Infinito</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f3f4f6;
            font-family: system-ui, -apple-system, sans-serif;
            user-select: none; /* Evitar selección de texto nativa al arrastrar */
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: default;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .cursor-pan { cursor: grab !important; }
        .cursor-panning { cursor: grabbing !important; }
        .cursor-crosshair { cursor: crosshair !important; }
        .cursor-pointer { cursor: pointer !important; }
        .cursor-nwse-resize { cursor: nwse-resize !important; }
        .cursor-nesw-resize { cursor: nesw-resize !important; }

        .toolbar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .tool-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: 2px solid transparent;
            background: transparent;
            color: #4b5563;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tool-btn:hover { background: #f3f4f6; }
        .tool-btn.active { background: #eff6ff; color: #3b82f6; border-color: #bfdbfe; }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            color: #4b5563;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            pointer-events: none;
            z-index: 10;
        }

        /* Estilos de la barra lateral */
        .sidebar {
            position: absolute;
            left: 20px;
            top: 20px;
            bottom: 20px;
            width: 250px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 16px;
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }
        .sidebar.visible { display: flex; }

        .color-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s;
        }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.active { outline: 2px solid #3b82f6; outline-offset: 2px; }
        
        .style-btn {
            flex: 1;
            padding: 6px 0;
            text-align: center;
            background: #f3f4f6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #4b5563;
            border: 1px solid transparent;
        }
        .style-btn:hover { background: #e5e7eb; }
        .style-btn.active { background: #eff6ff; color: #3b82f6; border-color: #bfdbfe; }

        #text-editor {
            position: absolute;
            display: none;
            z-index: 15;
            background: transparent;
            border: none;
            outline: none;
            resize: none;
            padding: 0;
            margin: 0;
            overflow: hidden;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        /* Menú Contextual */
        #context-menu {
            position: absolute;
            display: none;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            padding: 4px 0;
            min-width: 200px;
            z-index: 50;
            font-size: 14px;
        }
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.1s;
        }
        .context-menu-item:hover { background-color: #f3f4f6; }
        .context-menu-item.danger { color: #dc2626; }
        .context-menu-item.disabled { color: #9ca3af; pointer-events: none; }
        .context-menu-separator { height: 1px; background-color: #e5e7eb; margin: 4px 0; }
        .shortcut { font-size: 12px; color: #9ca3af; }
    </style>
</head>
<body>

    <div class="toolbar">
        <button id="btn-select" class="tool-btn active" title="Seleccionar y Mover (V)">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>
            Seleccionar
        </button>
        <button id="btn-box" class="tool-btn" title="Dibujar Caja (R)">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>
            Caja
        </button>
        <button id="btn-arrow" class="tool-btn" title="Dibujar Flecha (A)">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
            Flecha
        </button>
    </div>

    <div id="properties-sidebar" class="sidebar">
        <h2 class="text-lg font-bold text-gray-800 mb-4 border-b pb-2">Propiedades</h2>
        
        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Trazo</h3>
            <div class="flex gap-2 flex-wrap" id="stroke-colors">
                <div class="color-btn active" style="background: #1f2937; border-color: #1f2937" data-val="#1f2937"></div>
                <div class="color-btn" style="background: #ef4444; border-color: #ef4444" data-val="#ef4444"></div>
                <div class="color-btn" style="background: #22c55e; border-color: #22c55e" data-val="#22c55e"></div>
                <div class="color-btn" style="background: #3b82f6; border-color: #3b82f6" data-val="#3b82f6"></div>
                <div class="color-btn" style="background: #f97316; border-color: #f97316" data-val="#f97316"></div>
                <div class="color-btn flex items-center justify-center" style="background: transparent; border-color: #d1d5db" data-val="transparent" title="Sin borde">
                    <svg width="18" height="18" viewBox="0 0 24 24"><line x1="2" y1="2" x2="22" y2="22" stroke="#ef4444" stroke-width="2"/></svg>
                </div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Fondo</h3>
            <div class="flex gap-2 flex-wrap" id="bg-colors">
                <div class="color-btn flex items-center justify-center" style="background: transparent; border-color: #d1d5db" data-val="transparent" title="Sin fondo">
                    <svg width="18" height="18" viewBox="0 0 24 24"><line x1="2" y1="2" x2="22" y2="22" stroke="#ef4444" stroke-width="2"/></svg>
                </div>
                <div class="color-btn" style="background: #f3f4f6; border-color: #d1d5db" data-val="#f3f4f6"></div>
                <div class="color-btn active" style="background: #fef08a; border-color: #fde047" data-val="#fef08a"></div>
                <div class="color-btn" style="background: #bbf7d0; border-color: #86efac" data-val="#bbf7d0"></div>
                <div class="color-btn" style="background: #bfdbfe; border-color: #93c5fd" data-val="#bfdbfe"></div>
                <div class="color-btn" style="background: #fecaca; border-color: #fca5a5" data-val="#fecaca"></div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Tamaño de fuente</h3>
            <div class="flex gap-2" id="font-sizes">
                <div class="style-btn" data-val="S">S</div>
                <div class="style-btn active" data-val="M">M</div>
                <div class="style-btn" data-val="L">L</div>
                <div class="style-btn" data-val="XL">XL</div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Alineado horizontal</h3>
            <div class="flex gap-2" id="align-h">
                <div class="style-btn" data-val="left" title="Izquierda"><svg class="mx-auto" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="15" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div>
                <div class="style-btn active" data-val="center" title="Centro"><svg class="mx-auto" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="7" y1="12" x2="17" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div>
                <div class="style-btn" data-val="right" title="Derecha"><svg class="mx-auto" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="9" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Alineado vertical</h3>
            <div class="flex gap-2" id="align-v">
                <div class="style-btn" data-val="top">Arriba</div>
                <div class="style-btn active" data-val="middle">Medio</div>
                <div class="style-btn" data-val="bottom">Abajo</div>
            </div>
        </div>
    </div>

    <div class="instructions">
        <strong>Controles:</strong><br>
        • Clic derecho y arrastrar: <em>Mover el lienzo</em><br>
        • Clic derecho en elemento: <em>Menú contextual</em><br>
        • Arrastrar en vacío: <em>Selección múltiple</em><br>
        • Ctrl+C / Ctrl+V: <em>Copiar / Pegar</em><br>
        • Doble clic: <em>Editar texto</em>
    </div>

    <!-- Menú Contextual HTML -->
    <div id="context-menu">
        <div class="context-menu-item" id="cm-copy">Copiar <span class="shortcut">Ctrl+C</span></div>
        <div class="context-menu-item" id="cm-paste">Pegar <span class="shortcut">Ctrl+V</span></div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="cm-group">Agrupar <span class="shortcut">Ctrl+G</span></div>
        <div class="context-menu-item" id="cm-ungroup">Desagrupar <span class="shortcut">Ctrl+Shift+G</span></div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="cm-front">Traer al frente del todo</div>
        <div class="context-menu-item" id="cm-forward">Traer hacia delante</div>
        <div class="context-menu-item" id="cm-backward">Enviar hacia atrás</div>
        <div class="context-menu-item" id="cm-back">Enviar al fondo del todo</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item danger" id="cm-delete">Borrar <span class="shortcut">Supr</span></div>
    </div>

    <div id="canvas-container">
        <canvas id="app-canvas"></canvas>
        <textarea id="text-editor"></textarea>
    </div>

    <script>
        const canvas = document.getElementById('app-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const textEditor = document.getElementById('text-editor');
        const sidebar = document.getElementById('properties-sidebar');
        const contextMenu = document.getElementById('context-menu');

        // Estado de la aplicación actualizado para soportar selección múltiple
        let state = {
            mode: 'select', 
            camera: { x: 0, y: 0, zoom: 1 },
            boxes: [],
            arrows: [],
            selectedIds: [], // Ahora es un array (IDs de cajas y flechas)
            hoveredBoxId: null,
            editingTextId: null,
            clipboard: null, // Para copiar/pegar
            
            isPanning: false,
            panStartScreen: { x: 0, y: 0 },
            panStartCamera: { x: 0, y: 0 },
            
            isSelecting: false, // Selección múltiple (Lasso/Marquee)
            selectionStart: { x: 0, y: 0 },
            
            isDrawingBox: false,
            newBoxStart: { x: 0, y: 0 },
            
            isDragging: false,
            dragStartMouse: { x: 0, y: 0 },
            dragOriginalBoxes: [], // Estado de cajas antes de arrastrar
            
            isResizing: false,
            resizeHandle: null,
            resizeOriginalBounds: null,
            resizeOriginalBoxes: [],
            
            isDrawingArrow: false,
            arrowStartBoxId: null,
            mouseX: 0,
            mouseY: 0
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- Utilidades de Coordenadas y Geometría ---
        function screenToWorld(screenX, screenY) {
            return { x: (screenX - state.camera.x) / state.camera.zoom, y: (screenY - state.camera.y) / state.camera.zoom };
        }
        function worldToScreen(worldX, worldY) {
            return { x: worldX * state.camera.zoom + state.camera.x, y: worldY * state.camera.zoom + state.camera.y };
        }

        function isPointInBox(x, y, box) {
            return x >= box.x && x <= box.x + box.w && y >= box.y && y <= box.y + box.h;
        }

        // Calcula la distancia de un punto a un segmento (para seleccionar flechas)
        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt((p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2);
        }

        function getArrowAt(x, y) {
            for (let i = state.arrows.length - 1; i >= 0; i--) {
                const arrow = state.arrows[i];
                const boxA = state.boxes.find(b => b.id === arrow.from);
                const boxB = state.boxes.find(b => b.id === arrow.to);
                if (!boxA || !boxB) continue;
                
                const centerA = { x: boxA.x + boxA.w/2, y: boxA.y + boxA.h/2 };
                const centerB = { x: boxB.x + boxB.w/2, y: boxB.y + boxB.h/2 };
                const start = getBoxPerimeterPoint(boxA, centerB.x, centerB.y);
                const end = getBoxPerimeterPoint(boxB, centerA.x, centerA.y);
                
                if (distToSegment({x, y}, start, end) < 8 / state.camera.zoom) {
                    return arrow;
                }
            }
            return null;
        }

        // Obtener la caja delimitadora (Bounding Box) de todos los elementos seleccionados
        function getSelectionBounds() {
            const selectedBoxes = state.boxes.filter(b => state.selectedIds.includes(b.id));
            if (selectedBoxes.length === 0) return null;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            selectedBoxes.forEach(b => {
                minX = Math.min(minX, b.x); minY = Math.min(minY, b.y);
                maxX = Math.max(maxX, b.x + b.w); maxY = Math.max(maxY, b.y + b.h);
            });
            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
        }

        function getResizeHandles(bounds) {
            if (!bounds) return {};
            const size = 8 / state.camera.zoom;
            return {
                nw: { x: bounds.x - size/2, y: bounds.y - size/2, w: size, h: size },
                ne: { x: bounds.x + bounds.w - size/2, y: bounds.y - size/2, w: size, h: size },
                sw: { x: bounds.x - size/2, y: bounds.y + bounds.h - size/2, w: size, h: size },
                se: { x: bounds.x + bounds.w - size/2, y: bounds.y + bounds.h - size/2, w: size, h: size }
            };
        }

        function getHitResizeHandle(x, y, bounds) {
            if (!bounds) return null;
            const handles = getResizeHandles(bounds);
            for (const [pos, rect] of Object.entries(handles)) {
                if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) return pos;
            }
            return null;
        }

        function getBoxPerimeterPoint(box, targetX, targetY) {
            const cx = box.x + box.w / 2, cy = box.y + box.h / 2;
            const dx = targetX - cx, dy = targetY - cy;
            const angle = Math.atan2(dy, dx);
            const absCos = Math.abs(Math.cos(angle)), absSin = Math.abs(Math.sin(angle));
            let x, y;
            if (box.w / 2 * absSin <= box.h / 2 * absCos) {
                x = box.w / 2 * Math.sign(Math.cos(angle)); y = x * Math.tan(angle);
            } else {
                y = box.h / 2 * Math.sign(Math.sin(angle)); x = y / Math.tan(angle);
            }
            return { x: cx + x, y: cy + y };
        }

        // --- Lógica de Agrupación ---
        // Si seleccionas una caja que pertenece a un grupo, selecciona todas las demás del grupo automáticamente
        function resolveSelectionGroups() {
            let changed = true;
            while(changed) {
                changed = false;
                const groupsInSelection = new Set();
                state.boxes.forEach(b => {
                    if (state.selectedIds.includes(b.id) && b.groupId) groupsInSelection.add(b.groupId);
                });
                
                state.boxes.forEach(b => {
                    if (b.groupId && groupsInSelection.has(b.groupId) && !state.selectedIds.includes(b.id)) {
                        state.selectedIds.push(b.id);
                        changed = true;
                    }
                });
            }
        }

        // --- Acciones y Comandos ---
        function deleteSelected() {
            state.boxes = state.boxes.filter(b => !state.selectedIds.includes(b.id));
            // Eliminar flechas seleccionadas explícitamente, o aquellas conectadas a cajas eliminadas
            state.arrows = state.arrows.filter(a => 
                !state.selectedIds.includes(a.id) && 
                state.boxes.some(b => b.id === a.from) && 
                state.boxes.some(b => b.id === a.to)
            );
            state.selectedIds = [];
            updateSidebar(); render();
        }

        function copySelected() {
            const boxesToCopy = state.boxes.filter(b => state.selectedIds.includes(b.id)).map(b => ({...b}));
            const boxIds = boxesToCopy.map(b => b.id);
            // Copiar flechas si están seleccionadas o si AMBAS cajas de la flecha se copian
            const arrowsToCopy = state.arrows.filter(a => state.selectedIds.includes(a.id) || (boxIds.includes(a.from) && boxIds.includes(a.to))).map(a => ({...a}));
            state.clipboard = { boxes: boxesToCopy, arrows: arrowsToCopy };
        }

        function pasteSelected() {
            if (!state.clipboard || state.clipboard.boxes.length === 0) return;
            const newSelectedIds = [];
            const idMap = {};
            const groupMap = {}; // Para agrupar los elementos pegados entre sí
            
            state.clipboard.boxes.forEach(b => {
                const newId = generateId();
                idMap[b.id] = newId;
                const newBox = { ...b, id: newId, x: b.x + 20, y: b.y + 20 };
                
                if (b.groupId) {
                    if (!groupMap[b.groupId]) groupMap[b.groupId] = generateId();
                    newBox.groupId = groupMap[b.groupId];
                }
                
                state.boxes.push(newBox);
                newSelectedIds.push(newId);
            });

            state.clipboard.arrows.forEach(a => {
                const newId = generateId();
                const newFrom = idMap[a.from] || a.from;
                const newTo = idMap[a.to] || a.to;
                // Solo pegar flecha si sus cajas existen en el lienzo actual
                if (state.boxes.some(b=>b.id===newFrom) && state.boxes.some(b=>b.id===newTo)) {
                    state.arrows.push({ ...a, id: newId, from: newFrom, to: newTo });
                    if (state.selectedIds.includes(a.id)) newSelectedIds.push(newId);
                }
            });
            
            state.selectedIds = newSelectedIds;
            updateSidebar(); render();
        }

        // Funciones Z-Index (Capas)
        function bringToFront() {
            const selected = state.boxes.filter(b => state.selectedIds.includes(b.id));
            state.boxes = state.boxes.filter(b => !state.selectedIds.includes(b.id)).concat(selected);
            render();
        }
        function sendToBack() {
            const selected = state.boxes.filter(b => state.selectedIds.includes(b.id));
            state.boxes = selected.concat(state.boxes.filter(b => !state.selectedIds.includes(b.id)));
            render();
        }
        function bringForward() {
            for (let i = state.boxes.length - 2; i >= 0; i--) {
                if (state.selectedIds.includes(state.boxes[i].id) && !state.selectedIds.includes(state.boxes[i+1].id)) {
                    [state.boxes[i], state.boxes[i+1]] = [state.boxes[i+1], state.boxes[i]];
                }
            }
            render();
        }
        function sendBackward() {
            for (let i = 1; i < state.boxes.length; i++) {
                if (state.selectedIds.includes(state.boxes[i].id) && !state.selectedIds.includes(state.boxes[i-1].id)) {
                    [state.boxes[i], state.boxes[i-1]] = [state.boxes[i-1], state.boxes[i]];
                }
            }
            render();
        }

        // --- Renderizado ---
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; render(); }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            container.style.backgroundPosition = `${state.camera.x}px ${state.camera.y}px`;

            ctx.save();
            ctx.translate(state.camera.x, state.camera.y);
            ctx.scale(state.camera.zoom, state.camera.zoom);

            // 1. Dibujar Flechas
            ctx.lineWidth = 2;
            
            state.arrows.forEach(arrow => {
                const boxA = state.boxes.find(b => b.id === arrow.from);
                const boxB = state.boxes.find(b => b.id === arrow.to);
                if (boxA && boxB) {
                    const centerA = { x: boxA.x + boxA.w/2, y: boxA.y + boxA.h/2 };
                    const centerB = { x: boxB.x + boxB.w/2, y: boxB.y + boxB.h/2 };
                    const start = getBoxPerimeterPoint(boxA, centerB.x, centerB.y);
                    const end = getBoxPerimeterPoint(boxB, centerA.x, centerA.y);
                    
                    // Resaltar flecha si está seleccionada
                    if (state.selectedIds.includes(arrow.id)) {
                        ctx.strokeStyle = '#3b82f6'; ctx.fillStyle = '#3b82f6'; ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = '#9ca3af'; ctx.fillStyle = '#9ca3af'; ctx.lineWidth = 2;
                    }
                    drawArrow(start.x, start.y, end.x, end.y);
                }
            });

            // Flecha en progreso
            if (state.isDrawingArrow && state.arrowStartBoxId) {
                const boxA = state.boxes.find(b => b.id === state.arrowStartBoxId);
                if (boxA) {
                    const mouseWorld = screenToWorld(state.mouseX, state.mouseY);
                    let targetPoint = mouseWorld;
                    if (state.hoveredBoxId && state.hoveredBoxId !== boxA.id) {
                        const boxB = state.boxes.find(b => b.id === state.hoveredBoxId);
                        targetPoint = { x: boxB.x + boxB.w/2, y: boxB.y + boxB.h/2 };
                    }
                    const start = getBoxPerimeterPoint(boxA, targetPoint.x, targetPoint.y);
                    ctx.strokeStyle = '#9ca3af'; ctx.fillStyle = '#9ca3af'; ctx.lineWidth = 2;
                    drawArrow(start.x, start.y, mouseWorld.x, mouseWorld.y);
                }
            }

            // 2. Dibujar Cajas
            state.boxes.forEach(box => {
                const bgColor = box.backgroundColor || '#fef08a';
                const strokeColor = box.strokeColor || '#1f2937';
                ctx.fillStyle = bgColor;
                
                const isSelected = state.selectedIds.includes(box.id);
                
                if (isSelected) {
                    ctx.shadowColor = 'rgba(59, 130, 246, 0.5)'; ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2;
                } else if (box.id === state.hoveredBoxId && state.mode !== 'box') {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.1)'; ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#4b5563'; ctx.lineWidth = 2;
                } else {
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                    ctx.strokeStyle = strokeColor; ctx.lineWidth = 2;
                }

                ctx.beginPath();
                ctx.roundRect(box.x, box.y, box.w, box.h, 8);
                if (bgColor !== 'transparent') ctx.fill();
                if (strokeColor !== 'transparent') ctx.stroke();

                // Dibujar texto
                if (box.text && state.editingTextId !== box.id) {
                    ctx.fillStyle = '#1f2937';
                    let fontSize = 16;
                    if (box.fontSize === 'S') fontSize = 12; else if (box.fontSize === 'M') fontSize = 16;
                    else if (box.fontSize === 'L') fontSize = 24; else if (box.fontSize === 'XL') fontSize = 32;

                    ctx.font = `${fontSize}px system-ui, -apple-system, sans-serif`;
                    ctx.textAlign = box.textAlignH || 'center'; ctx.textBaseline = 'top'; 
                    
                    const lines = box.text.split('\n');
                    const lineHeight = fontSize * 1.2;
                    const totalHeight = lines.length * lineHeight;
                    const padding = 10;
                    
                    let startY = box.y + padding;
                    const alignV = box.textAlignV || 'middle';
                    if (alignV === 'middle') startY = box.y + (box.h - totalHeight) / 2;
                    else if (alignV === 'bottom') startY = box.y + box.h - padding - totalHeight;
                    
                    let xPos = box.x + box.w / 2;
                    const alignH = box.textAlignH || 'center';
                    if (alignH === 'left') xPos = box.x + padding;
                    else if (alignH === 'right') xPos = box.x + box.w - padding;

                    ctx.save(); ctx.beginPath(); ctx.roundRect(box.x, box.y, box.w, box.h, 8); ctx.clip();
                    lines.forEach((line, i) => ctx.fillText(line, xPos, startY + (i * lineHeight)));
                    ctx.restore();
                }
            });

            // Dibujar Bounding Box y Tiradores si hay selección y estamos en modo 'select'
            if (state.mode === 'select' && state.selectedIds.length > 0) {
                const bounds = getSelectionBounds();
                if (bounds) {
                    ctx.shadowColor = 'transparent';
                    
                    // Si hay múltiples elementos seleccionados, dibujar caja sutil alrededor de todos
                    if (state.selectedIds.length > 1) {
                        ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)';
                        ctx.setLineDash([4, 4]);
                        ctx.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);
                        ctx.setLineDash([]);
                    }

                    const handles = getResizeHandles(bounds);
                    ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2;
                    for (const pos in handles) {
                        const rect = handles[pos];
                        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                    }
                }
            }

            // 3. Dibujar acciones temporales (caja nueva o selección múltiple)
            if (state.isDrawingBox || state.isSelecting) {
                const mouseWorld = screenToWorld(state.mouseX, state.mouseY);
                const start = state.isDrawingBox ? state.newBoxStart : state.selectionStart;
                const x = Math.min(start.x, mouseWorld.x);
                const y = Math.min(start.y, mouseWorld.y);
                const w = Math.abs(mouseWorld.x - start.x);
                const h = Math.abs(mouseWorld.y - start.y);

                if (state.isDrawingBox) {
                    ctx.fillStyle = 'rgba(254, 240, 138, 0.5)';
                    ctx.strokeStyle = '#1f2937';
                } else { // Selección múltiple
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.1)'; // Azul translúcido
                    ctx.strokeStyle = '#3b82f6';
                }
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                if (state.isDrawingBox) ctx.roundRect(x, y, w, h, 8);
                else ctx.rect(x, y, w, h);
                ctx.fill(); ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        function drawArrow(fromX, fromY, toX, toY) {
            const headlen = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(toX, toY); ctx.fill();
        }

        // --- Edición de Texto ---
        canvas.addEventListener('dblclick', (e) => {
            if (e.button !== 0 || state.mode !== 'select') return;
            const mouseWorld = screenToWorld(e.clientX, e.clientY);
            let clickedBox = null;
            for (let i = state.boxes.length - 1; i >= 0; i--) {
                if (isPointInBox(mouseWorld.x, mouseWorld.y, state.boxes[i])) { clickedBox = state.boxes[i]; break; }
            }
            if (clickedBox) startTextEditing(clickedBox);
        });

        function startTextEditing(box) {
            state.editingTextId = box.id;
            textEditor.value = box.text || '';
            textEditor.style.display = 'block';
            
            const screenPos = worldToScreen(box.x, box.y);
            textEditor.style.left = screenPos.x + 'px'; textEditor.style.top = screenPos.y + 'px';
            textEditor.style.width = (box.w * state.camera.zoom) + 'px'; textEditor.style.height = (box.h * state.camera.zoom) + 'px';
            
            let fontSize = 16;
            if (box.fontSize === 'S') fontSize = 12; else if (box.fontSize === 'M') fontSize = 16;
            else if (box.fontSize === 'L') fontSize = 24; else if (box.fontSize === 'XL') fontSize = 32;
            textEditor.style.fontSize = (fontSize * state.camera.zoom) + 'px';
            textEditor.style.fontFamily = 'system-ui, -apple-system, sans-serif'; textEditor.style.color = '#1f2937';
            textEditor.style.padding = `${10 * state.camera.zoom}px`; textEditor.style.boxSizing = 'border-box';
            textEditor.style.textAlign = box.textAlignH || 'center';

            textEditor.focus(); textEditor.setSelectionRange(textEditor.value.length, textEditor.value.length);
            render();
        }

        textEditor.addEventListener('blur', () => {
            if (state.editingTextId) {
                const box = state.boxes.find(b => b.id === state.editingTextId);
                if (box) box.text = textEditor.value;
                state.editingTextId = null; textEditor.style.display = 'none'; render();
            }
        });
        textEditor.addEventListener('mousedown', (e) => e.stopPropagation());

        // --- Eventos del Ratón ---
        canvas.addEventListener('mousedown', (e) => {
            if (state.editingTextId) textEditor.blur();
            closeContextMenu();

            const mouseScreen = { x: e.clientX, y: e.clientY };
            const mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);
            
            // Clic derecho (Preparar para panning o Menú contextual)
            if (e.button === 2) {
                state.isPanning = true;
                state.panStartScreen = { x: mouseScreen.x, y: mouseScreen.y };
                state.panStartCamera = { x: state.camera.x, y: state.camera.y };
                
                // Si hizo clic derecho sobre algo no seleccionado, seleccionarlo primero
                let targetBox = state.boxes.slice().reverse().find(b => isPointInBox(mouseWorld.x, mouseWorld.y, b));
                if (targetBox && !state.selectedIds.includes(targetBox.id)) {
                    state.selectedIds = [targetBox.id];
                    resolveSelectionGroups();
                } else if (!targetBox) {
                    let targetArrow = getArrowAt(mouseWorld.x, mouseWorld.y);
                    if (targetArrow && !state.selectedIds.includes(targetArrow.id)) {
                        state.selectedIds = [targetArrow.id];
                    }
                }
                updateSidebar(); render();
                return;
            }

            // Solo botón izquierdo a partir de aquí
            if (e.button !== 0) return;

            let clickedBox = state.boxes.slice().reverse().find(b => isPointInBox(mouseWorld.x, mouseWorld.y, b));
            let clickedArrow = !clickedBox ? getArrowAt(mouseWorld.x, mouseWorld.y) : null;

            if (state.mode === 'select') {
                const bounds = getSelectionBounds();
                const handle = getHitResizeHandle(mouseWorld.x, mouseWorld.y, bounds);
                
                if (handle && state.selectedIds.length > 0) {
                    // Iniciar redimensión
                    state.isResizing = true;
                    state.resizeHandle = handle;
                    state.resizeOriginalBounds = bounds;
                    // Guardar estado original de las cajas seleccionadas
                    state.resizeOriginalBoxes = state.boxes.filter(b => state.selectedIds.includes(b.id)).map(b => ({...b}));
                    return;
                }

                if (clickedBox) {
                    // Seleccionar caja (y grupo) si no estaba seleccionada
                    if (!e.shiftKey && !state.selectedIds.includes(clickedBox.id)) {
                        state.selectedIds = [clickedBox.id];
                        resolveSelectionGroups();
                    } else if (e.shiftKey) {
                        if (state.selectedIds.includes(clickedBox.id)) state.selectedIds = state.selectedIds.filter(id => id !== clickedBox.id);
                        else { state.selectedIds.push(clickedBox.id); resolveSelectionGroups(); }
                    }
                    
                    // Iniciar arrastre
                    state.isDragging = true;
                    state.dragStartMouse = mouseWorld;
                    state.dragOriginalBoxes = state.boxes.filter(b => state.selectedIds.includes(b.id)).map(b => ({...b}));
                    
                } else if (clickedArrow) {
                    if (!e.shiftKey) state.selectedIds = [clickedArrow.id];
                    else state.selectedIds.push(clickedArrow.id);
                } else {
                    // Clic en vacío: iniciar selección múltiple (Lasso)
                    state.selectedIds = [];
                    state.isSelecting = true;
                    state.selectionStart = mouseWorld;
                }
            } 
            else if (state.mode === 'box') {
                state.isDrawingBox = true; state.newBoxStart = mouseWorld; state.selectedIds = [];
            }
            else if (state.mode === 'arrow') {
                if (clickedBox) {
                    state.isDrawingArrow = true; state.arrowStartBoxId = clickedBox.id; state.selectedIds = [clickedBox.id];
                } else state.selectedIds = [];
            }

            updateSidebar(); render();
        });

        canvas.addEventListener('mousemove', (e) => {
            state.mouseX = e.clientX; state.mouseY = e.clientY;
            const mouseScreen = { x: e.clientX, y: e.clientY };
            const mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);

            if (state.isPanning) {
                state.camera.x = state.panStartCamera.x + (mouseScreen.x - state.panStartScreen.x);
                state.camera.y = state.panStartCamera.y + (mouseScreen.y - state.panStartScreen.y);
                container.classList.add('cursor-panning');
                render(); return;
            }

            let newHovered = state.boxes.slice().reverse().find(b => isPointInBox(mouseWorld.x, mouseWorld.y, b))?.id || null;
            if (state.hoveredBoxId !== newHovered) { state.hoveredBoxId = newHovered; render(); }

            // Actualizar Cursores
            container.className = '';
            if (state.mode === 'box') container.classList.add('cursor-crosshair');
            else if (state.mode === 'arrow') {
                container.classList.add('cursor-crosshair');
                if (state.hoveredBoxId) container.classList.add('cursor-pointer');
            } else if (state.mode === 'select') {
                const handle = getHitResizeHandle(mouseWorld.x, mouseWorld.y, getSelectionBounds());
                if (handle === 'nw' || handle === 'se') container.classList.add('cursor-nwse-resize');
                else if (handle === 'ne' || handle === 'sw') container.classList.add('cursor-nesw-resize');
                else if (state.hoveredBoxId) container.classList.add('cursor-pan');
            }

            // Lógica de arrastre
            if (state.isDragging && state.selectedIds.length > 0) {
                const dx = mouseWorld.x - state.dragStartMouse.x;
                const dy = mouseWorld.y - state.dragStartMouse.y;
                state.dragOriginalBoxes.forEach(orig => {
                    const box = state.boxes.find(b => b.id === orig.id);
                    if (box) { box.x = orig.x + dx; box.y = orig.y + dy; }
                });
                render();
            }
            // Lógica de redimensión para 1 o múltiples elementos agrupados
            else if (state.isResizing && state.resizeOriginalBounds) {
                const origB = state.resizeOriginalBounds;
                let newX = origB.x, newY = origB.y, newW = origB.w, newH = origB.h;
                const minSize = 20;

                if (state.resizeHandle === 'se') { newW = Math.max(minSize, mouseWorld.x - origB.x); newH = Math.max(minSize, mouseWorld.y - origB.y); }
                else if (state.resizeHandle === 'sw') { newW = Math.max(minSize, origB.x + origB.w - mouseWorld.x); newX = origB.x + origB.w - newW; newH = Math.max(minSize, mouseWorld.y - origB.y); }
                else if (state.resizeHandle === 'ne') { newW = Math.max(minSize, mouseWorld.x - origB.x); newH = Math.max(minSize, origB.y + origB.h - mouseWorld.y); newY = origB.y + origB.h - newH; }
                else if (state.resizeHandle === 'nw') { newW = Math.max(minSize, origB.x + origB.w - mouseWorld.x); newX = origB.x + origB.w - newW; newH = Math.max(minSize, origB.y + origB.h - mouseWorld.y); newY = origB.y + origB.h - newH; }

                const scaleX = newW / origB.w;
                const scaleY = newH / origB.h;

                state.resizeOriginalBoxes.forEach(orig => {
                    const box = state.boxes.find(b => b.id === orig.id);
                    if (box) {
                        box.x = newX + (orig.x - origB.x) * scaleX;
                        box.y = newY + (orig.y - origB.y) * scaleY;
                        box.w = Math.max(10, orig.w * scaleX);
                        box.h = Math.max(10, orig.h * scaleY);
                    }
                });
                render();
            }
            else if (state.isDrawingBox || state.isDrawingArrow || state.isSelecting) {
                render();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const mouseScreen = { x: e.clientX, y: e.clientY };
            const mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);

            // Analizar Clic Derecho vs Arrastre Derecho
            if (e.button === 2) {
                state.isPanning = false;
                container.classList.remove('cursor-panning');
                const distMoved = Math.hypot(mouseScreen.x - state.panStartScreen.x, mouseScreen.y - state.panStartScreen.y);
                
                // Si casi no se movió, es un clic -> Mostrar menú contextual
                if (distMoved < 5) {
                    openContextMenu(mouseScreen.x, mouseScreen.y);
                }
                return;
            }

            if (state.isSelecting) {
                // Calcular qué elementos caen dentro de la caja de selección
                const x = Math.min(state.selectionStart.x, mouseWorld.x);
                const y = Math.min(state.selectionStart.y, mouseWorld.y);
                const w = Math.abs(mouseWorld.x - state.selectionStart.x);
                const h = Math.abs(mouseWorld.y - state.selectionStart.y);
                
                state.boxes.forEach(b => {
                    // Si hay intersección
                    if (b.x < x + w && b.x + b.w > x && b.y < y + h && b.y + b.h > y) {
                        if (!state.selectedIds.includes(b.id)) state.selectedIds.push(b.id);
                    }
                });
                resolveSelectionGroups();
            }
            else if (state.isDrawingBox) {
                const x = Math.min(state.newBoxStart.x, mouseWorld.x); const y = Math.min(state.newBoxStart.y, mouseWorld.y);
                const w = Math.max(Math.abs(mouseWorld.x - state.newBoxStart.x), 10); const h = Math.max(Math.abs(mouseWorld.y - state.newBoxStart.y), 10);
                if (w > 20 && h > 20) {
                    const newBox = { 
                        id: generateId(), x, y, w, h,
                        backgroundColor: '#fef08a', strokeColor: '#1f2937', 
                        fontSize: 'M', textAlignH: 'center', textAlignV: 'middle', text: ''
                    };
                    state.boxes.push(newBox);
                    state.selectedIds = [newBox.id];
                    setMode('select');
                }
            } 
            else if (state.isDrawingArrow && state.arrowStartBoxId) {
                if (state.hoveredBoxId && state.hoveredBoxId !== state.arrowStartBoxId) {
                    const exists = state.arrows.some(a => a.from === state.arrowStartBoxId && a.to === state.hoveredBoxId);
                    if (!exists) state.arrows.push({ id: generateId(), from: state.arrowStartBoxId, to: state.hoveredBoxId });
                }
                setMode('select');
            }

            // Reset States
            state.isSelecting = false; state.isDrawingBox = false; state.isDragging = false;
            state.isResizing = false; state.isDrawingArrow = false; state.arrowStartBoxId = null;
            state.resizeHandle = null; state.resizeOriginalBounds = null; state.dragOriginalBoxes = [];

            updateSidebar(); render();
        });

        // Prevenir menú contextual nativo
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // --- Lógica del Menú Contextual (Custom) ---
        function openContextMenu(x, y) {
            // Configurar visibilidad de opciones según selección
            const numBoxesSelected = state.boxes.filter(b => state.selectedIds.includes(b.id)).length;
            const isGrouped = numBoxesSelected > 0 && state.boxes.find(b => state.selectedIds.includes(b.id))?.groupId;

            document.getElementById('cm-group').style.display = numBoxesSelected > 1 ? 'flex' : 'none';
            document.getElementById('cm-ungroup').style.display = isGrouped ? 'flex' : 'none';
            document.getElementById('cm-paste').style.display = (state.clipboard && state.clipboard.boxes.length > 0) ? 'flex' : 'none';
            
            const hasSelection = state.selectedIds.length > 0;
            ['cm-copy', 'cm-delete', 'cm-front', 'cm-forward', 'cm-backward', 'cm-back'].forEach(id => {
                document.getElementById(id).style.display = hasSelection ? 'flex' : 'none';
            });

            // Evitar que el menú se salga de la pantalla
            contextMenu.style.display = 'block';
            const rect = contextMenu.getBoundingClientRect();
            let finalX = x, finalY = y;
            if (x + rect.width > window.innerWidth) finalX = window.innerWidth - rect.width;
            if (y + rect.height > window.innerHeight) finalY = window.innerHeight - rect.height;
            
            contextMenu.style.left = finalX + 'px';
            contextMenu.style.top = finalY + 'px';
        }

        function closeContextMenu() { contextMenu.style.display = 'none'; }

        // Eventos de los botones del menú contextual
        document.getElementById('cm-copy').addEventListener('click', () => { copySelected(); closeContextMenu(); });
        document.getElementById('cm-paste').addEventListener('click', () => { pasteSelected(); closeContextMenu(); });
        document.getElementById('cm-delete').addEventListener('click', () => { deleteSelected(); closeContextMenu(); });
        document.getElementById('cm-front').addEventListener('click', () => { bringToFront(); closeContextMenu(); });
        document.getElementById('cm-back').addEventListener('click', () => { sendToBack(); closeContextMenu(); });
        document.getElementById('cm-forward').addEventListener('click', () => { bringForward(); closeContextMenu(); });
        document.getElementById('cm-backward').addEventListener('click', () => { sendBackward(); closeContextMenu(); });
        
        document.getElementById('cm-group').addEventListener('click', () => {
            const gid = generateId();
            state.boxes.forEach(b => { if (state.selectedIds.includes(b.id)) b.groupId = gid; });
            closeContextMenu();
        });
        document.getElementById('cm-ungroup').addEventListener('click', () => {
            state.boxes.forEach(b => { if (state.selectedIds.includes(b.id)) b.groupId = null; });
            closeContextMenu();
        });


        // --- Atajos de Teclado ---
        window.addEventListener('keydown', (e) => {
            if (state.editingTextId) return;

            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            
            // Atajos de copiar y pegar (Ctrl+C / Ctrl+V / Cmd+C / Cmd+V)
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') copySelected();
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') pasteSelected();

            if (e.key.toLowerCase() === 'v' && !e.ctrlKey && !e.metaKey) setMode('select');
            if (e.key.toLowerCase() === 'r' && !e.ctrlKey && !e.metaKey) setMode('box');
            if (e.key.toLowerCase() === 'a' && !e.ctrlKey && !e.metaKey) setMode('arrow');
        });

        // --- Configuración de UI ---
        function setMode(newMode) {
            state.mode = newMode;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${newMode}`).classList.add('active');
            state.isDrawingBox = false; state.isDrawingArrow = false; state.isSelecting = false;
            canvas.dispatchEvent(new MouseEvent('mousemove', { clientX: state.mouseX, clientY: state.mouseY }));
            render();
        }

        document.getElementById('btn-select').addEventListener('click', () => setMode('select'));
        document.getElementById('btn-box').addEventListener('click', () => setMode('box'));
        document.getElementById('btn-arrow').addEventListener('click', () => setMode('arrow'));

        // --- Lógica de la Barra Lateral ---
        function updateSidebar() {
            const selectedBoxes = state.boxes.filter(b => state.selectedIds.includes(b.id));
            if (selectedBoxes.length > 0) {
                sidebar.classList.add('visible');
                // Usar propiedades de la primera caja seleccionada para el UI
                const box = selectedBoxes[0];
                const updateActiveBtn = (selector, value, defaultVal) => {
                    document.querySelectorAll(selector).forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.val === (value || defaultVal)) btn.classList.add('active');
                    });
                };

                updateActiveBtn('#stroke-colors .color-btn', box.strokeColor, '#1f2937');
                updateActiveBtn('#bg-colors .color-btn', box.backgroundColor, '#fef08a');
                updateActiveBtn('#font-sizes .style-btn', box.fontSize, 'M');
                updateActiveBtn('#align-h .style-btn', box.textAlignH, 'center');
                updateActiveBtn('#align-v .style-btn', box.textAlignV, 'middle');
            } else {
                sidebar.classList.remove('visible');
            }
        }

        function setupSidebarEvent(selector, propName) {
            document.querySelectorAll(selector).forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (state.selectedIds.length === 0) return;
                    const val = e.currentTarget.dataset.val;
                    // Aplicar a TODAS las cajas seleccionadas
                    state.selectedIds.forEach(id => {
                        const box = state.boxes.find(b => b.id === id);
                        if (box) box[propName] = val;
                    });
                    updateSidebar(); render();
                });
            });
        }

        setupSidebarEvent('#stroke-colors .color-btn', 'strokeColor');
        setupSidebarEvent('#bg-colors .color-btn', 'backgroundColor');
        setupSidebarEvent('#font-sizes .style-btn', 'fontSize');
        setupSidebarEvent('#align-h .style-btn', 'textAlignH');
        setupSidebarEvent('#align-v .style-btn', 'textAlignV');

        // --- Inicialización ---
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        state.camera.x = canvas.width / 2; state.camera.y = canvas.height / 2;
        
        state.boxes.push({
            id: generateId(), x: -100, y: -50, w: 200, h: 100,
            backgroundColor: '#fef08a', strokeColor: '#1f2937',
            text: 'Haz doble clic\npara editar',
            fontSize: 'M', textAlignH: 'center', textAlignV: 'middle'
        });

        render();
    </script>
</body>
</html>