<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagramador de Canvas Infinito</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f3f4f6;
            font-family: system-ui, -apple-system, sans-serif;
            user-select: none;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: default;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .cursor-pan { cursor: grab !important; }
        .cursor-panning { cursor: grabbing !important; }
        .cursor-crosshair { cursor: crosshair !important; }
        .cursor-pointer { cursor: pointer !important; }
        .cursor-nwse-resize { cursor: nwse-resize !important; }
        .cursor-nesw-resize { cursor: nesw-resize !important; }

        .toolbar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .tool-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: 2px solid transparent;
            background: transparent;
            color: #4b5563;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tool-btn:hover { background: #f3f4f6; }
        .tool-btn.active { background: #eff6ff; color: #3b82f6; border-color: #bfdbfe; }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            color: #4b5563;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            pointer-events: none;
            z-index: 10;
        }

        .sidebar {
            position: absolute;
            left: 20px;
            top: 20px;
            bottom: 20px;
            width: 260px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 16px;
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }
        .sidebar.visible { display: flex; }

        .color-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s;
        }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.active { outline: 2px solid #3b82f6; outline-offset: 2px; }
        
        .style-btn {
            flex: 1;
            padding: 6px 0;
            text-align: center;
            background: #f3f4f6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #4b5563;
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
        }
        .style-btn:hover { background: #e5e7eb; }
        .style-btn.active { background: #eff6ff; color: #3b82f6; border-color: #bfdbfe; }

        #text-editor {
            position: absolute;
            display: none;
            z-index: 15;
            background: transparent;
            border: none;
            outline: none;
            resize: none;
            padding: 0;
            margin: 0;
            overflow: hidden;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        #context-menu {
            position: absolute;
            display: none;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            padding: 4px 0;
            min-width: 200px;
            z-index: 50;
            font-size: 14px;
        }
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.1s;
        }
        .context-menu-item:hover { background-color: #f3f4f6; }
        .context-menu-item.danger { color: #dc2626; }
        .context-menu-item.disabled { color: #9ca3af; pointer-events: none; }
        .context-menu-separator { height: 1px; background-color: #e5e7eb; margin: 4px 0; }
        .shortcut { font-size: 12px; color: #9ca3af; }
    </style>
</head>
<body>

    <div class="toolbar">
        <button id="btn-select" class="tool-btn active" title="Seleccionar y Mover (V)">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>
            Seleccionar
        </button>
        <button id="btn-box" class="tool-btn" title="Dibujar Caja (R)">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>
            Caja
        </button>
        <button id="btn-arrow" class="tool-btn" title="Dibujar Flecha (A)">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
            Flecha
        </button>
    </div>

    <div id="properties-sidebar" class="sidebar">
        <h2 class="text-lg font-bold text-gray-800 mb-4 border-b pb-2">Propiedades</h2>
        
        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Trazo (Color)</h3>
            <div class="flex gap-2 flex-wrap" id="stroke-colors">
                <div class="color-btn active" style="background: #1f2937; border-color: #1f2937" data-val="#1f2937"></div>
                <div class="color-btn" style="background: #ef4444; border-color: #ef4444" data-val="#ef4444"></div>
                <div class="color-btn" style="background: #22c55e; border-color: #22c55e" data-val="#22c55e"></div>
                <div class="color-btn" style="background: #3b82f6; border-color: #3b82f6" data-val="#3b82f6"></div>
                <div class="color-btn" style="background: #f97316; border-color: #f97316" data-val="#f97316"></div>
                <div class="color-btn flex items-center justify-center" style="background: transparent; border-color: #d1d5db" data-val="transparent" title="Sin borde">
                    <svg width="18" height="18" viewBox="0 0 24 24"><line x1="2" y1="2" x2="22" y2="22" stroke="#ef4444" stroke-width="2"/></svg>
                </div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Grosor del trazo</h3>
            <div class="flex gap-2" id="stroke-widths">
                <div class="style-btn active" data-val="2" title="Fino"><svg width="24" height="24" viewBox="0 0 24 24"><line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="2"/></svg></div>
                <div class="style-btn" data-val="4" title="Medio"><svg width="24" height="24" viewBox="0 0 24 24"><line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="4"/></svg></div>
                <div class="style-btn" data-val="7" title="Grueso"><svg width="24" height="24" viewBox="0 0 24 24"><line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="7"/></svg></div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Estilo del trazo</h3>
            <div class="flex gap-2" id="stroke-styles">
                <div class="style-btn active" data-val="solid" title="Continua"><svg width="24" height="24" viewBox="0 0 24 24"><line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3"/></svg></div>
                <div class="style-btn" data-val="dashed" title="Discontinua"><svg width="24" height="24" viewBox="0 0 24 24"><line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3" stroke-dasharray="6 4"/></svg></div>
                <div class="style-btn" data-val="dotted" title="Punteada"><svg width="24" height="24" viewBox="0 0 24 24"><line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3" stroke-dasharray="2 4" stroke-linecap="round"/></svg></div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Fondo</h3>
            <div class="flex gap-2 flex-wrap" id="bg-colors">
                <div class="color-btn flex items-center justify-center" style="background: transparent; border-color: #d1d5db" data-val="transparent" title="Sin fondo">
                    <svg width="18" height="18" viewBox="0 0 24 24"><line x1="2" y1="2" x2="22" y2="22" stroke="#ef4444" stroke-width="2"/></svg>
                </div>
                <div class="color-btn active" style="background: #ffffff; border-color: #d1d5db" data-val="#ffffff"></div>
                <div class="color-btn" style="background: #fef08a; border-color: #fde047" data-val="#fef08a"></div>
                <div class="color-btn" style="background: #bbf7d0; border-color: #86efac" data-val="#bbf7d0"></div>
                <div class="color-btn" style="background: #bfdbfe; border-color: #93c5fd" data-val="#bfdbfe"></div>
                <div class="color-btn" style="background: #fecaca; border-color: #fca5a5" data-val="#fecaca"></div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Tamaño de fuente</h3>
            <div class="flex gap-2" id="font-sizes">
                <div class="style-btn" data-val="S">S</div>
                <div class="style-btn active" data-val="M">M</div>
                <div class="style-btn" data-val="L">L</div>
                <div class="style-btn" data-val="XL">XL</div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Alineado horizontal</h3>
            <div class="flex gap-2" id="align-h">
                <div class="style-btn" data-val="left" title="Izquierda"><svg class="mx-auto" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="15" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div>
                <div class="style-btn active" data-val="center" title="Centro"><svg class="mx-auto" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="7" y1="12" x2="17" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div>
                <div class="style-btn" data-val="right" title="Derecha"><svg class="mx-auto" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="9" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div>
            </div>
        </div>

        <div class="mb-5">
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Alineado vertical</h3>
            <div class="flex gap-2" id="align-v">
                <div class="style-btn" data-val="top">Arriba</div>
                <div class="style-btn active" data-val="middle">Medio</div>
                <div class="style-btn" data-val="bottom">Abajo</div>
            </div>
        </div>
    </div>

    <div class="instructions">
        <strong>Controles:</strong><br>
        • Clic derecho y arrastrar: <em>Mover el lienzo</em><br>
        • Clic derecho en elemento: <em>Menú contextual</em><br>
        • Arrastrar en vacío: <em>Selección múltiple</em><br>
        • Ctrl+C / Ctrl+V: <em>Copiar / Pegar</em><br>
        • Doble clic: <em>Editar texto (cajas y flechas)</em><br>
        • Arrastrar punto azul: <em>Curvar flecha seleccionada</em>
    </div>

    <div id="context-menu">
        <div class="context-menu-item" id="cm-copy">Copiar <span class="shortcut">Ctrl+C</span></div>
        <div class="context-menu-item" id="cm-paste">Pegar <span class="shortcut">Ctrl+V</span></div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="cm-group">Agrupar <span class="shortcut">Ctrl+G</span></div>
        <div class="context-menu-item" id="cm-ungroup">Desagrupar <span class="shortcut">Ctrl+Shift+G</span></div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="cm-front">Traer al frente del todo</div>
        <div class="context-menu-item" id="cm-forward">Traer hacia delante</div>
        <div class="context-menu-item" id="cm-backward">Enviar hacia atrás</div>
        <div class="context-menu-item" id="cm-back">Enviar al fondo del todo</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item danger" id="cm-delete">Borrar <span class="shortcut">Supr</span></div>
    </div>

    <div id="canvas-container">
        <canvas id="app-canvas"></canvas>
        <textarea id="text-editor"></textarea>
    </div>

    <script>
        const canvas = document.getElementById('app-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const textEditor = document.getElementById('text-editor');
        const sidebar = document.getElementById('properties-sidebar');
        const contextMenu = document.getElementById('context-menu');

        let state = {
            mode: 'select', 
            camera: { x: 0, y: 0, zoom: 1 },
            boxes: [],
            arrows: [],
            selectedIds: [], 
            hoveredBoxId: null,
            editingTextId: null,
            clipboard: null, 
            
            isPanning: false,
            panStartScreen: { x: 0, y: 0 },
            panStartCamera: { x: 0, y: 0 },
            
            isSelecting: false, 
            selectionStart: { x: 0, y: 0 },
            
            isDrawingBox: false,
            newBoxStart: { x: 0, y: 0 },
            
            isDragging: false,
            dragStartMouse: { x: 0, y: 0 },
            dragOriginalBoxes: [], 
            
            isResizing: false,
            resizeHandle: null,
            resizeOriginalBounds: null,
            resizeOriginalBoxes: [],
            
            isDraggingArrowHandle: false,
            activeArrowId: null,

            isDrawingArrow: false,
            arrowStartBoxId: null,
            mouseX: 0,
            mouseY: 0
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- Utilidades de Coordenadas y Geometría ---
        function screenToWorld(screenX, screenY) {
            return { x: (screenX - state.camera.x) / state.camera.zoom, y: (screenY - state.camera.y) / state.camera.zoom };
        }
        function worldToScreen(worldX, worldY) {
            return { x: worldX * state.camera.zoom + state.camera.x, y: worldY * state.camera.zoom + state.camera.y };
        }

        function isPointInBox(x, y, box) {
            return x >= box.x && x <= box.x + box.w && y >= box.y && y <= box.y + box.h;
        }

        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt((p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2);
        }

        function getBoxPerimeterPoint(box, targetX, targetY) {
            const cx = box.x + box.w / 2, cy = box.y + box.h / 2;
            const dx = targetX - cx, dy = targetY - cy;
            const angle = Math.atan2(dy, dx);
            const absCos = Math.abs(Math.cos(angle)), absSin = Math.abs(Math.sin(angle));
            let x, y;
            if (box.w / 2 * absSin <= box.h / 2 * absCos) {
                x = box.w / 2 * Math.sign(Math.cos(angle)); y = x * Math.tan(angle);
            } else {
                y = box.h / 2 * Math.sign(Math.sin(angle)); x = y / Math.tan(angle);
            }
            return { x: cx + x, y: cy + y };
        }

        // Calcula la curva Bezier completa de una flecha
        function getArrowCurve(arrow) {
            const boxA = state.boxes.find(b => b.id === arrow.from);
            const boxB = state.boxes.find(b => b.id === arrow.to);
            if (!boxA || !boxB) return null;
            
            const centerA = { x: boxA.x + boxA.w/2, y: boxA.y + boxA.h/2 };
            const centerB = { x: boxB.x + boxB.w/2, y: boxB.y + boxB.h/2 };
            
            const cpRaw = arrow.cp || {dx: 0, dy: 0};
            const M_centers = { x: (centerA.x+centerB.x)/2, y: (centerA.y+centerB.y)/2 };
            const C_target = { x: M_centers.x + cpRaw.dx, y: M_centers.y + cpRaw.dy };

            const S = getBoxPerimeterPoint(boxA, C_target.x, C_target.y);
            const E = getBoxPerimeterPoint(boxB, C_target.x, C_target.y);
            
            const M = { x: (S.x+E.x)/2, y: (S.y+E.y)/2 };
            const C = { x: M.x + cpRaw.dx, y: M.y + cpRaw.dy };
            const T = { 
                x: 0.25*S.x + 0.5*C.x + 0.25*E.x,
                y: 0.25*S.y + 0.5*C.y + 0.25*E.y
            };

            return { S, E, C, M, T };
        }

        function getArrowAt(x, y) {
            for (let i = state.arrows.length - 1; i >= 0; i--) {
                const curve = getArrowCurve(state.arrows[i]);
                if (!curve) continue;
                
                // Aproximación por segmentos para colisiones precisas con curvas
                let prev = curve.S;
                let hit = false;
                for (let t = 0.1; t <= 1; t += 0.1) {
                    const px = (1-t)*(1-t)*curve.S.x + 2*(1-t)*t*curve.C.x + t*t*curve.E.x;
                    const py = (1-t)*(1-t)*curve.S.y + 2*(1-t)*t*curve.C.y + t*t*curve.E.y;
                    if (distToSegment({x, y}, prev, {x:px, y:py}) < 10 / state.camera.zoom) {
                        hit = true; break;
                    }
                    prev = {x:px, y:py};
                }
                // Permitir click en el punto central directamente
                if (Math.hypot(curve.T.x - x, curve.T.y - y) < 15 / state.camera.zoom) hit = true;
                
                if (hit) return state.arrows[i];
            }
            return null;
        }

        function getSelectionBounds() {
            const selectedBoxes = state.boxes.filter(b => state.selectedIds.includes(b.id));
            if (selectedBoxes.length === 0) return null;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            selectedBoxes.forEach(b => {
                minX = Math.min(minX, b.x); minY = Math.min(minY, b.y);
                maxX = Math.max(maxX, b.x + b.w); maxY = Math.max(maxY, b.y + b.h);
            });
            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
        }

        function getResizeHandles(bounds) {
            if (!bounds) return {};
            const size = 8 / state.camera.zoom;
            return {
                nw: { x: bounds.x - size/2, y: bounds.y - size/2, w: size, h: size },
                ne: { x: bounds.x + bounds.w - size/2, y: bounds.y - size/2, w: size, h: size },
                sw: { x: bounds.x - size/2, y: bounds.y + bounds.h - size/2, w: size, h: size },
                se: { x: bounds.x + bounds.w - size/2, y: bounds.y + bounds.h - size/2, w: size, h: size }
            };
        }

        function getHitResizeHandle(x, y, bounds) {
            if (!bounds) return null;
            const handles = getResizeHandles(bounds);
            for (const [pos, rect] of Object.entries(handles)) {
                if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) return pos;
            }
            return null;
        }

        // --- Lógica de Agrupación ---
        function resolveSelectionGroups() {
            let changed = true;
            while(changed) {
                changed = false;
                const groupsInSelection = new Set();
                state.boxes.forEach(b => {
                    if (state.selectedIds.includes(b.id) && b.groupId) groupsInSelection.add(b.groupId);
                });
                state.boxes.forEach(b => {
                    if (b.groupId && groupsInSelection.has(b.groupId) && !state.selectedIds.includes(b.id)) {
                        state.selectedIds.push(b.id);
                        changed = true;
                    }
                });
            }
        }

        // --- Acciones y Comandos ---
        function deleteSelected() {
            state.boxes = state.boxes.filter(b => !state.selectedIds.includes(b.id));
            state.arrows = state.arrows.filter(a => 
                !state.selectedIds.includes(a.id) && 
                state.boxes.some(b => b.id === a.from) && 
                state.boxes.some(b => b.id === a.to)
            );
            state.selectedIds = [];
            updateSidebar(); render();
        }

        function copySelected() {
            const boxesToCopy = state.boxes.filter(b => state.selectedIds.includes(b.id)).map(b => ({...b}));
            const boxIds = boxesToCopy.map(b => b.id);
            const arrowsToCopy = state.arrows.filter(a => state.selectedIds.includes(a.id) || (boxIds.includes(a.from) && boxIds.includes(a.to))).map(a => ({...a}));
            state.clipboard = { boxes: boxesToCopy, arrows: arrowsToCopy };
        }

        function pasteSelected() {
            if (!state.clipboard || (state.clipboard.boxes.length === 0 && state.clipboard.arrows.length === 0)) return;
            const newSelectedIds = [];
            const idMap = {};
            const groupMap = {}; 
            
            state.clipboard.boxes.forEach(b => {
                const newId = generateId();
                idMap[b.id] = newId;
                const newBox = { ...b, id: newId, x: b.x + 20, y: b.y + 20 };
                if (b.groupId) {
                    if (!groupMap[b.groupId]) groupMap[b.groupId] = generateId();
                    newBox.groupId = groupMap[b.groupId];
                }
                state.boxes.push(newBox);
                newSelectedIds.push(newId);
            });

            state.clipboard.arrows.forEach(a => {
                const newId = generateId();
                const newFrom = idMap[a.from] || a.from;
                const newTo = idMap[a.to] || a.to;
                
                // Determinar si la flecha se pega sin haber copiado sus cajas base
                const standalonePaste = !idMap[a.from] && !idMap[a.to];
                // Si se pega de forma independiente, aumentamos la curvatura para que no se solape perfectamente con la original
                const newCp = standalonePaste ? { dx: (a.cp?.dx||0) + 40, dy: (a.cp?.dy||0) + 40 } : { ...(a.cp || {dx:0, dy:0}) };
                
                if (state.boxes.some(b=>b.id===newFrom) && state.boxes.some(b=>b.id===newTo)) {
                    state.arrows.push({ ...a, id: newId, from: newFrom, to: newTo, cp: newCp });
                    if (state.selectedIds.includes(a.id) || standalonePaste) newSelectedIds.push(newId);
                }
            });
            
            state.selectedIds = newSelectedIds;
            updateSidebar(); render();
        }

        function bringToFront() {
            const selected = state.boxes.filter(b => state.selectedIds.includes(b.id));
            state.boxes = state.boxes.filter(b => !state.selectedIds.includes(b.id)).concat(selected);
            render();
        }
        function sendToBack() {
            const selected = state.boxes.filter(b => state.selectedIds.includes(b.id));
            state.boxes = selected.concat(state.boxes.filter(b => !state.selectedIds.includes(b.id)));
            render();
        }
        function bringForward() {
            for (let i = state.boxes.length - 2; i >= 0; i--) {
                if (state.selectedIds.includes(state.boxes[i].id) && !state.selectedIds.includes(state.boxes[i+1].id)) {
                    [state.boxes[i], state.boxes[i+1]] = [state.boxes[i+1], state.boxes[i]];
                }
            }
            render();
        }
        function sendBackward() {
            for (let i = 1; i < state.boxes.length; i++) {
                if (state.selectedIds.includes(state.boxes[i].id) && !state.selectedIds.includes(state.boxes[i-1].id)) {
                    [state.boxes[i], state.boxes[i-1]] = [state.boxes[i-1], state.boxes[i]];
                }
            }
            render();
        }

        // Configurar el contexto de trazo
        function applyStrokeStyles(ctx, element) {
            ctx.lineWidth = parseInt(element.strokeWidth) || 2;
            const style = element.strokeStyle || 'solid';
            if (style === 'dashed') ctx.setLineDash([8, 8]);
            else if (style === 'dotted') ctx.setLineDash([2, 4]);
            else ctx.setLineDash([]);
            if (style === 'dotted') ctx.lineCap = 'round'; else ctx.lineCap = 'butt';
        }

        function renderText(text, x, y, width, height, fontSizeStr, alignH, alignV, isArrow) {
            let fontSize = 16;
            if (fontSizeStr === 'S') fontSize = 12; else if (fontSizeStr === 'M') fontSize = 16;
            else if (fontSizeStr === 'L') fontSize = 24; else if (fontSizeStr === 'XL') fontSize = 32;

            ctx.font = `${fontSize}px system-ui, -apple-system, sans-serif`;
            ctx.textAlign = alignH || 'center'; 
            ctx.textBaseline = 'top'; 
            
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2;
            const totalHeight = lines.length * lineHeight;
            const padding = 10;
            
            let startY = y + padding;
            let xPos = x + width / 2;

            if (isArrow) {
                // En flechas, x e y ya son el centro del texto
                startY = y - totalHeight / 2;
                xPos = x;
                
                // Fondo semi-transparente suave para leer el texto
                const maxW = Math.max(...lines.map(l => ctx.measureText(l).width));
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.roundRect(x - maxW/2 - 6, startY - 4, maxW + 12, totalHeight + 8, 4);
                ctx.fill();
            } else {
                if (alignV === 'middle') startY = y + (height - totalHeight) / 2;
                else if (alignV === 'bottom') startY = y + height - padding - totalHeight;
                if (alignH === 'left') xPos = x + padding;
                else if (alignH === 'right') xPos = x + width - padding;
            }

            ctx.fillStyle = '#1f2937';
            lines.forEach((line, i) => ctx.fillText(line, xPos, startY + (i * lineHeight)));
        }

        // --- Renderizado ---
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; render(); }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            container.style.backgroundPosition = `${state.camera.x}px ${state.camera.y}px`;

            ctx.save();
            ctx.translate(state.camera.x, state.camera.y);
            ctx.scale(state.camera.zoom, state.camera.zoom);

            // 1. Dibujar Flechas
            state.arrows.forEach(arrow => {
                const curve = getArrowCurve(arrow);
                if (!curve) return;
                
                const isSelected = state.selectedIds.includes(arrow.id);
                
                ctx.strokeStyle = isSelected ? '#3b82f6' : (arrow.strokeColor || '#9ca3af'); 
                ctx.fillStyle = isSelected ? '#3b82f6' : (arrow.strokeColor || '#9ca3af');
                
                applyStrokeStyles(ctx, arrow);
                
                // Dibujar línea curva
                ctx.beginPath();
                ctx.moveTo(curve.S.x, curve.S.y);
                ctx.quadraticCurveTo(curve.C.x, curve.C.y, curve.E.x, curve.E.y);
                ctx.stroke();
                
                ctx.setLineDash([]); // Cabeza de flecha siempre solida
                
                // Dibujar cabeza
                const headlen = 10 + (parseInt(arrow.strokeWidth)||2);
                const angle = Math.atan2(curve.E.y - curve.C.y, curve.E.x - curve.C.x);
                ctx.beginPath();
                ctx.moveTo(curve.E.x, curve.E.y);
                ctx.lineTo(curve.E.x - headlen * Math.cos(angle - Math.PI / 6), curve.E.y - headlen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(curve.E.x - headlen * Math.cos(angle + Math.PI / 6), curve.E.y - headlen * Math.sin(angle + Math.PI / 6));
                ctx.lineTo(curve.E.x, curve.E.y); 
                ctx.fill();

                // Dibujar punto de control si está seleccionada
                if (isSelected && state.mode === 'select') {
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(curve.T.x, curve.T.y, 6 / state.camera.zoom, 0, 2*Math.PI);
                    ctx.fill(); ctx.stroke();
                }

                // Dibujar Texto
                if (arrow.text && state.editingTextId !== arrow.id) {
                    renderText(arrow.text, curve.T.x, curve.T.y, 0, 0, arrow.fontSize, 'center', 'middle', true);
                }
            });
            ctx.setLineDash([]); // Reset final

            // Flecha en progreso (recta temporal)
            if (state.isDrawingArrow && state.arrowStartBoxId) {
                const boxA = state.boxes.find(b => b.id === state.arrowStartBoxId);
                if (boxA) {
                    const mouseWorld = screenToWorld(state.mouseX, state.mouseY);
                    let targetPoint = mouseWorld;
                    if (state.hoveredBoxId && state.hoveredBoxId !== boxA.id) {
                        const boxB = state.boxes.find(b => b.id === state.hoveredBoxId);
                        targetPoint = { x: boxB.x + boxB.w/2, y: boxB.y + boxB.h/2 };
                    }
                    const start = getBoxPerimeterPoint(boxA, targetPoint.x, targetPoint.y);
                    ctx.strokeStyle = '#9ca3af'; ctx.fillStyle = '#9ca3af'; ctx.lineWidth = 2;
                    
                    const headlen = 10;
                    const angle = Math.atan2(mouseWorld.y - start.y, mouseWorld.x - start.x);
                    ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(mouseWorld.x, mouseWorld.y); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(mouseWorld.x, mouseWorld.y);
                    ctx.lineTo(mouseWorld.x - headlen * Math.cos(angle - Math.PI / 6), mouseWorld.y - headlen * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(mouseWorld.x - headlen * Math.cos(angle + Math.PI / 6), mouseWorld.y - headlen * Math.sin(angle + Math.PI / 6));
                    ctx.lineTo(mouseWorld.x, mouseWorld.y); ctx.fill();
                }
            }

            // 2. Dibujar Cajas
            state.boxes.forEach(box => {
                const bgColor = box.backgroundColor || '#ffffff'; // Default blanco
                const strokeColor = box.strokeColor || '#1f2937';
                ctx.fillStyle = bgColor;
                
                const isSelected = state.selectedIds.includes(box.id);
                
                applyStrokeStyles(ctx, box);
                if (isSelected) {
                    ctx.shadowColor = 'rgba(59, 130, 246, 0.5)'; ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#3b82f6'; 
                } else if (box.id === state.hoveredBoxId && state.mode !== 'box') {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.1)'; ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#4b5563';
                } else {
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                    ctx.strokeStyle = strokeColor;
                }

                ctx.beginPath();
                ctx.roundRect(box.x, box.y, box.w, box.h, 8);
                if (bgColor !== 'transparent') ctx.fill();
                if (strokeColor !== 'transparent') ctx.stroke();
                ctx.setLineDash([]); ctx.lineCap = 'butt'; // Reset

                // Dibujar texto
                if (box.text && state.editingTextId !== box.id) {
                    ctx.save(); ctx.beginPath(); ctx.roundRect(box.x, box.y, box.w, box.h, 8); ctx.clip();
                    renderText(box.text, box.x, box.y, box.w, box.h, box.fontSize, box.textAlignH, box.textAlignV, false);
                    ctx.restore();
                }
            });

            // Dibujar Bounding Box y Tiradores si hay selección
            if (state.mode === 'select' && state.selectedIds.length > 0 && !state.isDraggingArrowHandle) {
                const bounds = getSelectionBounds();
                if (bounds) {
                    ctx.shadowColor = 'transparent';
                    if (state.selectedIds.length > 1) {
                        ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)';
                        ctx.setLineDash([4, 4]); ctx.lineWidth = 1;
                        ctx.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);
                        ctx.setLineDash([]);
                    }

                    // No dibujar handles si SOLO hay flechas seleccionadas
                    const boxesSelected = state.boxes.some(b => state.selectedIds.includes(b.id));
                    if (boxesSelected) {
                        const handles = getResizeHandles(bounds);
                        ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2;
                        for (const pos in handles) {
                            const rect = handles[pos];
                            ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                            ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                        }
                    }
                }
            }

            // 3. Dibujar acciones temporales (caja nueva o selección múltiple)
            if (state.isDrawingBox || state.isSelecting) {
                const mouseWorld = screenToWorld(state.mouseX, state.mouseY);
                const start = state.isDrawingBox ? state.newBoxStart : state.selectionStart;
                const x = Math.min(start.x, mouseWorld.x);
                const y = Math.min(start.y, mouseWorld.y);
                const w = Math.abs(mouseWorld.x - start.x);
                const h = Math.abs(mouseWorld.y - start.y);

                if (state.isDrawingBox) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.strokeStyle = '#1f2937';
                } else { 
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.1)'; 
                    ctx.strokeStyle = '#3b82f6';
                }
                ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
                ctx.beginPath();
                if (state.isDrawingBox) ctx.roundRect(x, y, w, h, 8);
                else ctx.rect(x, y, w, h);
                ctx.fill(); ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        // --- Edición de Texto ---
        canvas.addEventListener('dblclick', (e) => {
            if (e.button !== 0 || state.mode !== 'select') return;
            const mouseWorld = screenToWorld(e.clientX, e.clientY);
            
            let clickedObj = state.boxes.slice().reverse().find(b => isPointInBox(mouseWorld.x, mouseWorld.y, b));
            if (!clickedObj) clickedObj = getArrowAt(mouseWorld.x, mouseWorld.y);
            
            if (clickedObj) startTextEditing(clickedObj);
        });

        function startTextEditing(obj) {
            state.editingTextId = obj.id;
            textEditor.value = obj.text || '';
            textEditor.style.display = 'block';
            
            let tx, ty, tw, th;
            if (obj.w !== undefined) { // Es una caja
                const screenPos = worldToScreen(obj.x, obj.y);
                tx = screenPos.x; ty = screenPos.y;
                tw = obj.w * state.camera.zoom; th = obj.h * state.camera.zoom;
                textEditor.style.textAlign = obj.textAlignH || 'center';
            } else { // Es una flecha
                const curve = getArrowCurve(obj);
                const screenPos = worldToScreen(curve.T.x, curve.T.y);
                tw = 150 * state.camera.zoom; th = 100 * state.camera.zoom;
                tx = screenPos.x - tw/2; ty = screenPos.y - th/2;
                textEditor.style.textAlign = 'center';
            }

            textEditor.style.left = tx + 'px'; textEditor.style.top = ty + 'px';
            textEditor.style.width = tw + 'px'; textEditor.style.height = th + 'px';
            
            let fontSize = 16;
            if (obj.fontSize === 'S') fontSize = 12; else if (obj.fontSize === 'M') fontSize = 16;
            else if (obj.fontSize === 'L') fontSize = 24; else if (obj.fontSize === 'XL') fontSize = 32;
            textEditor.style.fontSize = (fontSize * state.camera.zoom) + 'px';
            textEditor.style.fontFamily = 'system-ui, -apple-system, sans-serif'; textEditor.style.color = '#1f2937';
            textEditor.style.padding = `${10 * state.camera.zoom}px`; textEditor.style.boxSizing = 'border-box';

            textEditor.focus(); textEditor.setSelectionRange(textEditor.value.length, textEditor.value.length);
            render();
        }

        textEditor.addEventListener('blur', () => {
            if (state.editingTextId) {
                const box = state.boxes.find(b => b.id === state.editingTextId);
                const arrow = state.arrows.find(a => a.id === state.editingTextId);
                const obj = box || arrow;
                if (obj) obj.text = textEditor.value;
                state.editingTextId = null; textEditor.style.display = 'none'; render();
            }
        });
        textEditor.addEventListener('mousedown', (e) => e.stopPropagation());

        // --- Eventos del Ratón ---
        canvas.addEventListener('mousedown', (e) => {
            if (state.editingTextId) textEditor.blur();
            closeContextMenu();

            const mouseScreen = { x: e.clientX, y: e.clientY };
            const mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);
            
            if (e.button === 2) {
                state.isPanning = true;
                state.panStartScreen = { x: mouseScreen.x, y: mouseScreen.y };
                state.panStartCamera = { x: state.camera.x, y: state.camera.y };
                
                let targetBox = state.boxes.slice().reverse().find(b => isPointInBox(mouseWorld.x, mouseWorld.y, b));
                if (targetBox && !state.selectedIds.includes(targetBox.id)) {
                    state.selectedIds = [targetBox.id];
                    resolveSelectionGroups();
                } else if (!targetBox) {
                    let targetArrow = getArrowAt(mouseWorld.x, mouseWorld.y);
                    if (targetArrow && !state.selectedIds.includes(targetArrow.id)) state.selectedIds = [targetArrow.id];
                }
                updateSidebar(); render();
                return;
            }

            if (e.button !== 0) return;

            let clickedBox = state.boxes.slice().reverse().find(b => isPointInBox(mouseWorld.x, mouseWorld.y, b));
            let clickedArrow = !clickedBox ? getArrowAt(mouseWorld.x, mouseWorld.y) : null;

            if (state.mode === 'select') {
                // Comprobar si se hace clic en el punto de control de una flecha seleccionada
                let hitArrowHandle = null;
                for (let id of state.selectedIds) {
                    const a = state.arrows.find(arr => arr.id === id);
                    if (a) {
                        const c = getArrowCurve(a);
                        if (c && Math.hypot(c.T.x - mouseWorld.x, c.T.y - mouseWorld.y) < 15/state.camera.zoom) {
                            hitArrowHandle = a; break;
                        }
                    }
                }

                if (hitArrowHandle) {
                    state.isDraggingArrowHandle = true;
                    state.activeArrowId = hitArrowHandle.id;
                    return;
                }

                const bounds = getSelectionBounds();
                const handle = getHitResizeHandle(mouseWorld.x, mouseWorld.y, bounds);
                
                if (handle && state.selectedIds.length > 0 && state.boxes.some(b=>state.selectedIds.includes(b.id))) {
                    state.isResizing = true;
                    state.resizeHandle = handle;
                    state.resizeOriginalBounds = bounds;
                    state.resizeOriginalBoxes = state.boxes.filter(b => state.selectedIds.includes(b.id)).map(b => ({...b}));
                    return;
                }

                if (clickedBox) {
                    if (!e.shiftKey && !state.selectedIds.includes(clickedBox.id)) {
                        state.selectedIds = [clickedBox.id];
                        resolveSelectionGroups();
                    } else if (e.shiftKey) {
                        if (state.selectedIds.includes(clickedBox.id)) state.selectedIds = state.selectedIds.filter(id => id !== clickedBox.id);
                        else { state.selectedIds.push(clickedBox.id); resolveSelectionGroups(); }
                    }
                    
                    state.isDragging = true;
                    state.dragStartMouse = mouseWorld;
                    state.dragOriginalBoxes = state.boxes.filter(b => state.selectedIds.includes(b.id)).map(b => ({...b}));
                    
                } else if (clickedArrow) {
                    if (!e.shiftKey) state.selectedIds = [clickedArrow.id];
                    else state.selectedIds.push(clickedArrow.id);
                } else {
                    state.selectedIds = [];
                    state.isSelecting = true;
                    state.selectionStart = mouseWorld;
                }
            } 
            else if (state.mode === 'box') {
                state.isDrawingBox = true; state.newBoxStart = mouseWorld; state.selectedIds = [];
            }
            else if (state.mode === 'arrow') {
                if (clickedBox) {
                    state.isDrawingArrow = true; state.arrowStartBoxId = clickedBox.id; state.selectedIds = [clickedBox.id];
                } else state.selectedIds = [];
            }

            updateSidebar(); render();
        });

        canvas.addEventListener('mousemove', (e) => {
            state.mouseX = e.clientX; state.mouseY = e.clientY;
            const mouseScreen = { x: e.clientX, y: e.clientY };
            const mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);

            if (state.isPanning) {
                state.camera.x = state.panStartCamera.x + (mouseScreen.x - state.panStartScreen.x);
                state.camera.y = state.panStartCamera.y + (mouseScreen.y - state.panStartScreen.y);
                container.classList.add('cursor-panning');
                render(); return;
            }

            let newHovered = state.boxes.slice().reverse().find(b => isPointInBox(mouseWorld.x, mouseWorld.y, b))?.id || null;
            if (state.hoveredBoxId !== newHovered) { state.hoveredBoxId = newHovered; render(); }

            container.className = '';
            if (state.mode === 'box') container.classList.add('cursor-crosshair');
            else if (state.mode === 'arrow') {
                container.classList.add('cursor-crosshair');
                if (state.hoveredBoxId) container.classList.add('cursor-pointer');
            } else if (state.mode === 'select') {
                let hoverHandle = false;
                for (let id of state.selectedIds) {
                    const a = state.arrows.find(arr => arr.id === id);
                    if (a) {
                        const c = getArrowCurve(a);
                        if (c && Math.hypot(c.T.x - mouseWorld.x, c.T.y - mouseWorld.y) < 15/state.camera.zoom) {
                            hoverHandle = true; break;
                        }
                    }
                }
                
                if (hoverHandle) container.classList.add('cursor-pan'); // Cambiar cursor al flotar punto curva
                else {
                    const bounds = getSelectionBounds();
                    const boxesSelected = state.boxes.some(b => state.selectedIds.includes(b.id));
                    const handle = boxesSelected ? getHitResizeHandle(mouseWorld.x, mouseWorld.y, bounds) : null;
                    if (handle === 'nw' || handle === 'se') container.classList.add('cursor-nwse-resize');
                    else if (handle === 'ne' || handle === 'sw') container.classList.add('cursor-nesw-resize');
                    else if (state.hoveredBoxId) container.classList.add('cursor-pan');
                }
            }

            // Lógica curvar flecha
            if (state.isDraggingArrowHandle && state.activeArrowId) {
                const a = state.arrows.find(arr => arr.id === state.activeArrowId);
                const boxA = state.boxes.find(b => b.id === a.from);
                const boxB = state.boxes.find(b => b.id === a.to);
                if (boxA && boxB) {
                    const centerA = { x: boxA.x + boxA.w/2, y: boxA.y + boxA.h/2 };
                    const centerB = { x: boxB.x + boxB.w/2, y: boxB.y + boxB.h/2 };
                    const S = getBoxPerimeterPoint(boxA, centerB.x, centerB.y);
                    const E = getBoxPerimeterPoint(boxB, centerA.x, centerA.y);
                    const M = { x: (S.x+E.x)/2, y: (S.y+E.y)/2 };
                    // Calcular nuevo punto de control de Bezier para que la curva pase por el ratón (T)
                    // C = 2*T - 0.5*S - 0.5*E
                    const C = {
                        x: 2*mouseWorld.x - 0.5*S.x - 0.5*E.x,
                        y: 2*mouseWorld.y - 0.5*S.y - 0.5*E.y
                    };
                    a.cp = { dx: C.x - M.x, dy: C.y - M.y };
                    render();
                }
            }
            // Lógica de arrastre
            else if (state.isDragging && state.selectedIds.length > 0) {
                const dx = mouseWorld.x - state.dragStartMouse.x;
                const dy = mouseWorld.y - state.dragStartMouse.y;
                state.dragOriginalBoxes.forEach(orig => {
                    const box = state.boxes.find(b => b.id === orig.id);
                    if (box) { box.x = orig.x + dx; box.y = orig.y + dy; }
                });
                render();
            }
            // Lógica de redimensión
            else if (state.isResizing && state.resizeOriginalBounds) {
                const origB = state.resizeOriginalBounds;
                let newX = origB.x, newY = origB.y, newW = origB.w, newH = origB.h;
                const minSize = 20;

                if (state.resizeHandle === 'se') { newW = Math.max(minSize, mouseWorld.x - origB.x); newH = Math.max(minSize, mouseWorld.y - origB.y); }
                else if (state.resizeHandle === 'sw') { newW = Math.max(minSize, origB.x + origB.w - mouseWorld.x); newX = origB.x + origB.w - newW; newH = Math.max(minSize, mouseWorld.y - origB.y); }
                else if (state.resizeHandle === 'ne') { newW = Math.max(minSize, mouseWorld.x - origB.x); newH = Math.max(minSize, origB.y + origB.h - mouseWorld.y); newY = origB.y + origB.h - newH; }
                else if (state.resizeHandle === 'nw') { newW = Math.max(minSize, origB.x + origB.w - mouseWorld.x); newX = origB.x + origB.w - newW; newH = Math.max(minSize, origB.y + origB.h - mouseWorld.y); newY = origB.y + origB.h - newH; }

                const scaleX = newW / origB.w;
                const scaleY = newH / origB.h;

                state.resizeOriginalBoxes.forEach(orig => {
                    const box = state.boxes.find(b => b.id === orig.id);
                    if (box) {
                        box.x = newX + (orig.x - origB.x) * scaleX;
                        box.y = newY + (orig.y - origB.y) * scaleY;
                        box.w = Math.max(10, orig.w * scaleX);
                        box.h = Math.max(10, orig.h * scaleY);
                    }
                });
                render();
            }
            else if (state.isDrawingBox || state.isDrawingArrow || state.isSelecting) {
                render();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const mouseScreen = { x: e.clientX, y: e.clientY };
            const mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);

            if (e.button === 2) {
                state.isPanning = false;
                container.classList.remove('cursor-panning');
                const distMoved = Math.hypot(mouseScreen.x - state.panStartScreen.x, mouseScreen.y - state.panStartScreen.y);
                if (distMoved < 5) openContextMenu(mouseScreen.x, mouseScreen.y);
                return;
            }

            if (state.isSelecting) {
                const x = Math.min(state.selectionStart.x, mouseWorld.x);
                const y = Math.min(state.selectionStart.y, mouseWorld.y);
                const w = Math.abs(mouseWorld.x - state.selectionStart.x);
                const h = Math.abs(mouseWorld.y - state.selectionStart.y);
                
                state.boxes.forEach(b => {
                    if (b.x < x + w && b.x + b.w > x && b.y < y + h && b.y + b.h > y) {
                        if (!state.selectedIds.includes(b.id)) state.selectedIds.push(b.id);
                    }
                });
                resolveSelectionGroups();
            }
            else if (state.isDrawingBox) {
                const x = Math.min(state.newBoxStart.x, mouseWorld.x); const y = Math.min(state.newBoxStart.y, mouseWorld.y);
                const w = Math.max(Math.abs(mouseWorld.x - state.newBoxStart.x), 10); const h = Math.max(Math.abs(mouseWorld.y - state.newBoxStart.y), 10);
                if (w > 20 && h > 20) {
                    const newBox = { 
                        id: generateId(), x, y, w, h,
                        backgroundColor: '#ffffff', strokeColor: '#1f2937', strokeWidth: 2, strokeStyle: 'solid',
                        fontSize: 'M', textAlignH: 'center', textAlignV: 'middle', text: ''
                    };
                    state.boxes.push(newBox);
                    state.selectedIds = [newBox.id];
                    setMode('select');
                }
            } 
            else if (state.isDrawingArrow && state.arrowStartBoxId) {
                if (state.hoveredBoxId && state.hoveredBoxId !== state.arrowStartBoxId) {
                    const exists = state.arrows.some(a => a.from === state.arrowStartBoxId && a.to === state.hoveredBoxId);
                    if (!exists) {
                        state.arrows.push({ 
                            id: generateId(), from: state.arrowStartBoxId, to: state.hoveredBoxId, 
                            cp: {dx:0, dy:0}, strokeColor: '#9ca3af', strokeWidth: 2, strokeStyle: 'solid', fontSize: 'M', text: '' 
                        });
                    }
                }
                setMode('select');
            }

            state.isSelecting = false; state.isDrawingBox = false; state.isDragging = false;
            state.isResizing = false; state.isDrawingArrow = false; state.arrowStartBoxId = null;
            state.resizeHandle = null; state.resizeOriginalBounds = null; state.dragOriginalBoxes = [];
            state.isDraggingArrowHandle = false; state.activeArrowId = null;

            updateSidebar(); render();
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // --- Lógica del Menú Contextual (Custom) ---
        function openContextMenu(x, y) {
            const numBoxesSelected = state.boxes.filter(b => state.selectedIds.includes(b.id)).length;
            const isGrouped = numBoxesSelected > 0 && state.boxes.find(b => state.selectedIds.includes(b.id))?.groupId;

            document.getElementById('cm-group').style.display = numBoxesSelected > 1 ? 'flex' : 'none';
            document.getElementById('cm-ungroup').style.display = isGrouped ? 'flex' : 'none';
            document.getElementById('cm-paste').style.display = (state.clipboard && (state.clipboard.boxes.length > 0 || state.clipboard.arrows.length > 0)) ? 'flex' : 'none';
            
            const hasSelection = state.selectedIds.length > 0;
            ['cm-copy', 'cm-delete', 'cm-front', 'cm-forward', 'cm-backward', 'cm-back'].forEach(id => {
                document.getElementById(id).style.display = hasSelection ? 'flex' : 'none';
            });

            contextMenu.style.display = 'block';
            const rect = contextMenu.getBoundingClientRect();
            let finalX = x, finalY = y;
            if (x + rect.width > window.innerWidth) finalX = window.innerWidth - rect.width;
            if (y + rect.height > window.innerHeight) finalY = window.innerHeight - rect.height;
            
            contextMenu.style.left = finalX + 'px';
            contextMenu.style.top = finalY + 'px';
        }

        function closeContextMenu() { contextMenu.style.display = 'none'; }

        document.getElementById('cm-copy').addEventListener('click', () => { copySelected(); closeContextMenu(); });
        document.getElementById('cm-paste').addEventListener('click', () => { pasteSelected(); closeContextMenu(); });
        document.getElementById('cm-delete').addEventListener('click', () => { deleteSelected(); closeContextMenu(); });
        document.getElementById('cm-front').addEventListener('click', () => { bringToFront(); closeContextMenu(); });
        document.getElementById('cm-back').addEventListener('click', () => { sendToBack(); closeContextMenu(); });
        document.getElementById('cm-forward').addEventListener('click', () => { bringForward(); closeContextMenu(); });
        document.getElementById('cm-backward').addEventListener('click', () => { sendBackward(); closeContextMenu(); });
        
        document.getElementById('cm-group').addEventListener('click', () => {
            const gid = generateId();
            state.boxes.forEach(b => { if (state.selectedIds.includes(b.id)) b.groupId = gid; });
            closeContextMenu();
        });
        document.getElementById('cm-ungroup').addEventListener('click', () => {
            state.boxes.forEach(b => { if (state.selectedIds.includes(b.id)) b.groupId = null; });
            closeContextMenu();
        });


        // --- Atajos de Teclado ---
        window.addEventListener('keydown', (e) => {
            if (state.editingTextId) return;

            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') copySelected();
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') pasteSelected();

            if (e.key.toLowerCase() === 'v' && !e.ctrlKey && !e.metaKey) setMode('select');
            if (e.key.toLowerCase() === 'r' && !e.ctrlKey && !e.metaKey) setMode('box');
            if (e.key.toLowerCase() === 'a' && !e.ctrlKey && !e.metaKey) setMode('arrow');
        });

        // --- Configuración de UI ---
        function setMode(newMode) {
            state.mode = newMode;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${newMode}`).classList.add('active');
            state.isDrawingBox = false; state.isDrawingArrow = false; state.isSelecting = false;
            canvas.dispatchEvent(new MouseEvent('mousemove', { clientX: state.mouseX, clientY: state.mouseY }));
            render();
        }

        document.getElementById('btn-select').addEventListener('click', () => setMode('select'));
        document.getElementById('btn-box').addEventListener('click', () => setMode('box'));
        document.getElementById('btn-arrow').addEventListener('click', () => setMode('arrow'));

        // --- Lógica de la Barra Lateral ---
        function updateSidebar() {
            if (state.selectedIds.length > 0) {
                sidebar.classList.add('visible');
                
                // Coger primer elemento para setear interfaz (caja o flecha)
                const objId = state.selectedIds[0];
                const obj = state.boxes.find(b => b.id === objId) || state.arrows.find(a => a.id === objId);
                
                if (!obj) return;

                const updateActiveBtn = (selector, value, defaultVal) => {
                    document.querySelectorAll(selector).forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.val == (value || defaultVal)) btn.classList.add('active');
                    });
                };

                updateActiveBtn('#stroke-colors .color-btn', obj.strokeColor, '#1f2937');
                updateActiveBtn('#stroke-widths .style-btn', obj.strokeWidth, 2);
                updateActiveBtn('#stroke-styles .style-btn', obj.strokeStyle, 'solid');
                
                // Si es caja aplicamos fondo
                if (obj.w !== undefined) updateActiveBtn('#bg-colors .color-btn', obj.backgroundColor, '#ffffff');
                else updateActiveBtn('#bg-colors .color-btn', null, '#ffffff'); // Reset visual flechas

                updateActiveBtn('#font-sizes .style-btn', obj.fontSize, 'M');
                updateActiveBtn('#align-h .style-btn', obj.textAlignH, 'center');
                updateActiveBtn('#align-v .style-btn', obj.textAlignV, 'middle');
            } else {
                sidebar.classList.remove('visible');
            }
        }

        function setupSidebarEvent(selector, propName) {
            document.querySelectorAll(selector).forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (state.selectedIds.length === 0) return;
                    const val = e.currentTarget.dataset.val;
                    
                    state.selectedIds.forEach(id => {
                        const box = state.boxes.find(b => b.id === id);
                        const arrow = state.arrows.find(a => a.id === id);
                        const obj = box || arrow;
                        if (obj) obj[propName] = val;
                    });
                    updateSidebar(); render();
                });
            });
        }

        setupSidebarEvent('#stroke-colors .color-btn', 'strokeColor');
        setupSidebarEvent('#stroke-widths .style-btn', 'strokeWidth');
        setupSidebarEvent('#stroke-styles .style-btn', 'strokeStyle');
        setupSidebarEvent('#bg-colors .color-btn', 'backgroundColor');
        setupSidebarEvent('#font-sizes .style-btn', 'fontSize');
        setupSidebarEvent('#align-h .style-btn', 'textAlignH');
        setupSidebarEvent('#align-v .style-btn', 'textAlignV');

        // --- Inicialización ---
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        state.camera.x = canvas.width / 2; state.camera.y = canvas.height / 2;
        
        state.boxes.push({
            id: generateId(), x: -100, y: -50, w: 200, h: 100,
            backgroundColor: '#ffffff', strokeColor: '#1f2937', strokeWidth: 2, strokeStyle: 'solid',
            text: 'Haz doble clic\npara editar',
            fontSize: 'M', textAlignH: 'center', textAlignV: 'middle'
        });

        render();
    </script>
</body>
</html>